/**
 * File generated by Jenny -- https://github.com/LanderlYoung/Jenny
 *
 * DO NOT EDIT THIS FILE.
 *
 * For bug report, please refer to github issue tracker https://github.com/LanderlYoung/Jenny/issues.
 */
/* C++ header file for class io/github/landerlyoung/jennysampleapp/ComputeIntensiveClass$NestedNativeClass */
#pragma once

#include <jni.h>

namespace NestedNativeClass {

// DO NOT modify
static constexpr auto FULL_CLASS_NAME = u8"io/github/landerlyoung/jennysampleapp/ComputeIntensiveClass$NestedNativeClass";

static constexpr jint CONST = 0;

/*
 * Class:     io.github.landerlyoung.jennysampleapp.ComputeIntensiveClass$NestedNativeClass
 * Method:    public java.util.HashMap<java.lang.String,java.lang.String> one(java.lang.String param)
 * Signature: (Ljava/lang/String;)Ljava/util/HashMap;
 */
jobject JNICALL one(JNIEnv* env, jobject thiz, jstring param);

/*
 * Class:     io.github.landerlyoung.jennysampleapp.ComputeIntensiveClass$NestedNativeClass
 * Method:    public long nativeInit()
 * Signature: ()J
 */
jlong JNICALL nativeInit(JNIEnv* env, jobject thiz);

/*
 * Class:     io.github.landerlyoung.jennysampleapp.ComputeIntensiveClass$NestedNativeClass
 * Method:    public void testOverload()
 * Signature: ()V
 */
void JNICALL testOverload__(JNIEnv* env, jobject thiz);

/*
 * Class:     io.github.landerlyoung.jennysampleapp.ComputeIntensiveClass$NestedNativeClass
 * Method:    public void testOverload(java.lang.Object o)
 * Signature: (Ljava/lang/Object;)V
 */
void JNICALL testOverload__Ljava_lang_Object_2(JNIEnv* env, jobject thiz, jobject o);

/*
 * Class:     io.github.landerlyoung.jennysampleapp.ComputeIntensiveClass$NestedNativeClass
 * Method:    public void nativeRelease(long handle)
 * Signature: (J)V
 */
void JNICALL nativeRelease(JNIEnv* env, jobject thiz, jlong handle);


/**
* register Native functions
* @returns success or not
*/
inline bool registerNativeFunctions(JNIEnv* env) {
// 1. C++20 has u8"" string as char8_t type, we should cast them.
// 2. jni.h has JNINativeMethod::name as char* type not const char*. (while Android does)
#define jenny_u8cast(u8) const_cast<char *>(reinterpret_cast<const char *>(u8))
#define jenny_fpcast(fn) reinterpret_cast<void *>(fn)
    const JNINativeMethod nativeMethods[] = {
       {
           /* method name      */ jenny_u8cast(u8"one"),
           /* method signature */ jenny_u8cast(u8"(Ljava/lang/String;)Ljava/util/HashMap;"),
           /* function pointer */ jenny_fpcast(one)
       },
       {
           /* method name      */ jenny_u8cast(u8"nativeInit"),
           /* method signature */ jenny_u8cast(u8"()J"),
           /* function pointer */ jenny_fpcast(nativeInit)
       },
       {
           /* method name      */ jenny_u8cast(u8"testOverload"),
           /* method signature */ jenny_u8cast(u8"()V"),
           /* function pointer */ jenny_fpcast(testOverload__)
       },
       {
           /* method name      */ jenny_u8cast(u8"testOverload"),
           /* method signature */ jenny_u8cast(u8"(Ljava/lang/Object;)V"),
           /* function pointer */ jenny_fpcast(testOverload__Ljava_lang_Object_2)
       },
       {
           /* method name      */ jenny_u8cast(u8"nativeRelease"),
           /* method signature */ jenny_u8cast(u8"(J)V"),
           /* function pointer */ jenny_fpcast(nativeRelease)
       }
   };

   const int nativeMethodCount = sizeof(nativeMethods) / sizeof(JNINativeMethod);

   bool success = false;
   jclass clazz = env->FindClass(jenny_u8cast(FULL_CLASS_NAME));
   if (clazz != nullptr) {
       success = !env->RegisterNatives(clazz, nativeMethods, nativeMethodCount);
       env->DeleteLocalRef(clazz);
   }
   return success;
#undef jenny_fpcast
#undef jenny_u8cast
}

} // end of namespace NestedNativeClass
